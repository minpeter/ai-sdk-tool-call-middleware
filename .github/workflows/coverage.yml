name: Coverage Upload

on:
  push:
    branches: [main]
  pull_request:

jobs:
  coverage:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "pnpm"

      - name: Install (workspace root)
        run: pnpm -w install --frozen-lockfile

      - name: Build (workspace root)
        run: pnpm -w build

      - name: Run tests (auto-detect, parallel, coverage when supported)
        run: |
          set -euo pipefail
          echo "Detecting workspace packages with package.json under packages/ and examples/..."
          mapfile -t PKGS < <(find packages examples -maxdepth 2 -type f -name package.json 2>/dev/null || true)
          if [ ${#PKGS[@]} -eq 0 ]; then
            echo "No workspace packages found. Exiting."
            exit 0
          fi

          cmds=()
          for PJ in "${PKGS[@]}"; do
            DIR=$(dirname "$PJ")
            NAME=$(node -e "const fs=require('fs'); const p=JSON.parse(fs.readFileSync(process.argv[1],'utf8')); console.log(p.name||'')" "$PJ")
            TEST_SCRIPT=$(node -e "const fs=require('fs'); const p=JSON.parse(fs.readFileSync(process.argv[1],'utf8')); console.log((p.scripts&&p.scripts.test)||'')" "$PJ")
            HAS_VITEST=0
            # detect vitest by test script or dependencies
            if echo "$TEST_SCRIPT" | grep -qi "vitest"; then
              HAS_VITEST=1
            else
              node -e "const fs=require('fs');const p=JSON.parse(fs.readFileSync(process.argv[1],'utf8')); const deps=Object.assign({},p.dependencies||{},p.devDependencies||{}); const has=Object.keys(deps).some(k=>/vitest/i.test(k)); process.exit(has?0:1)" "$PJ" && HAS_VITEST=1 || HAS_VITEST=${HAS_VITEST}
            fi

            if [ "$HAS_VITEST" -eq 1 ]; then
              echo "Will run with coverage: $NAME"
              cmds+=("pnpm --filter \"$NAME\" run test -- --coverage")
            else
              echo "Will run without coverage: $NAME"
              cmds+=("pnpm --filter \"$NAME\" run test")
            fi
          done

          # run commands serially to ensure coverage files are reliably written
          for c in "${cmds[@]}"; do
            echo "Running: $c"
            bash -lc "$c"
            # Debug: check if coverage was generated after each test run
            echo "Checking for coverage files after running: $c"
            find . -name "lcov.info" -type f 2>/dev/null | head -10 || echo "No lcov.info files found yet"
          done

      - name: Merge LCOV files
        run: |
          echo "Merging LCOV files into ./coverage/lcov.info"
          mkdir -p coverage
          set -euo pipefail
          # find lcov files
          mapfile -t LCOVS < <(find . -type f -name lcov.info 2>/dev/null || true)
          if [ ${#LCOVS[@]} -eq 0 ]; then
            echo "No lcov.info files found, skipping merge."
            exit 0
          fi

          echo "Found ${#LCOVS[@]} lcov files"
          # try lcov-result-merger via pnpm dlx (no -y flag)
          if command -v pnpm >/dev/null 2>&1; then
            pnpm dlx lcov-result-merger "${LCOVS[@]}" -o coverage/lcov.info || true
          fi

          # if merger didn't create merged file or it's empty, fallback to safe concat
          if [ ! -s coverage/lcov.info ]; then
            echo "Falling back to concatenation for LCOV files"
            # create header/footer safe concatenation to avoid duplicates of 'end_of_record'
            > coverage/lcov.info
            for f in "${LCOVS[@]}"; do
              # skip empty files
              if [ -s "$f" ]; then
                # remove potential 'end_of_record' duplicates
                sed '/^end_of_record$/d' "$f" >> coverage/lcov.info || true
                echo "end_of_record" >> coverage/lcov.info
              fi
            done
          fi

          echo "Merged file size: $(stat -c%s coverage/lcov.info || echo 0)"

      - name: List generated coverage files (debug)
        run: |
          echo "Searching for coverage files"
          find . -type f -name lcov.info || true
          echo "Listing coverage directories"
          find . -type d -name coverage -maxdepth 4 -print -exec ls -la {} \; || true

      - name: Check for merged coverage
        id: check_cov
        run: |
          if [ -s coverage/lcov.info ]; then
            echo "found=true" >> $GITHUB_OUTPUT
          else
            # also check for any per-package lcovs
            if find . -type f -name lcov.info | grep -q .; then
              echo "found=true" >> $GITHUB_OUTPUT
            else
              echo "found=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Upload coverage to Codecov
        if: steps.check_cov.outputs.found == 'true'
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: |
            coverage/lcov.info
            **/coverage/lcov.info
          fail_ci_if_error: false
          verbose: true

      - name: Coverage upload summary
        run: |
          echo "âœ… Coverage files were found and processed"
          echo "ðŸ“Š Coverage has been uploaded to Codecov"
          echo "ðŸ”’ Note: CODECOV_TOKEN is required for protected branches"
